"""
Agent Manager module for managing AI agent lifecycle and interactions.

This module provides the AgentManager class which handles the creation,
management, and message processing for AI agents using LangChain and LangGraph.
All tools are now loaded via MCP (Model Context Protocol) servers.
"""

from typing import Dict

from dotenv import load_dotenv
from langchain.chat_models import init_chat_model
from langgraph.graph.state import CompiledStateGraph
from langgraph.prebuilt import create_react_agent

from services import get_http_mcp_client
from services.http_mcp_tool_adapter import HTTPMCPToolAdapter

# Load environment variables
load_dotenv()


class AgentManager:
    """
    Manages the lifecycle and interactions of conversation and tool agents.
    """

    def __init__(self):
        """
        Initializes the AgentManager with MCP tool loading only.
        """
        self.static_tools = []
        self.mcp_tools = []
        self.model = None
        self.agents: Dict[str, CompiledStateGraph] = {}
        self.http_mcp_client = get_http_mcp_client()
        self.tool_adapter = HTTPMCPToolAdapter(self.http_mcp_client)
        self._tools_loaded = False

        # Try to initialize the model, but continue without it if credentials are missing
        try:
            self.model = init_chat_model("google_genai:gemini-2.5-flash")
        except Exception as e:
            print(f"Warning: Could not initialize Google Gemini model: {e}")
            print("Agent will continue without LLM capabilities")

        # Tools will be loaded lazily when first needed

    async def _load_all_tools(self):
        """Load all MCP tools."""
        if not self._tools_loaded:
            await self._load_mcp_tools()
            self._tools_loaded = True

    async def _load_mcp_tools(self):
        """Load tools from HTTP MCP service."""
        try:
            self.mcp_tools = await self.tool_adapter.load_tools()
            print(f"Loaded {len(self.mcp_tools)} HTTP MCP tools")
        except Exception as e:
            print(f"Failed to load HTTP MCP tools: {e}")
            self.mcp_tools = []

    def _get_all_tools(self) -> list:
        """Get all available tools (static + MCP)."""
        return self.static_tools + self.mcp_tools

    async def _ensure_tools_loaded(self):
        """Ensure tools are loaded before using them."""
        if not self._tools_loaded:
            await self._load_all_tools()

    async def _create_agent(self, session_id: str) -> CompiledStateGraph:
        """Creates a new agent for the given session ID.
        :param session_id: Unique identifier for the session.
        :return: An instance of CompiledStateGraph.
        """
        if session_id in self.agents:
            raise ValueError(f"Agent with session_id {session_id} already exists.")

        if self.model is None:
            raise ValueError("Cannot create agent: Language model is not available")

        # Ensure tools are loaded
        await self._ensure_tools_loaded()

        all_tools = self._get_all_tools()
        agent = create_react_agent(
            tools=all_tools,
            model=self.model,
        )
        self.agents[session_id] = agent
        return self.agents[session_id]

    async def _get_or_create_agent(self, session_id: str) -> CompiledStateGraph:
        """Retrieves an existing agent or creates a new one if it doesn't exist.
        :param session_id: Unique identifier for the session.
        """
        if session_id not in self.agents:
            return await self._create_agent(session_id)
        return self.agents[session_id]

    async def process_message(self, session_id: str, user_input: str) -> str:
        """Processes a user input message through the agent for the given session ID.
        :param session_id: Unique identifier for the session.
        :param user_input: The input message from the user.
        :return: The response generated by the agent.
        """
        if self.model is None:
            return "Error: Language model is not available. Please configure proper credentials."

        agent = await self._get_or_create_agent(session_id)
        response = agent.invoke({"messages": [{"role": "user", "content": user_input}]})

        # Extract the final message content from LangGraph response
        if isinstance(response, dict):
            # LangGraph typically returns {"messages": [...]}
            if (
                "messages" in response
                and isinstance(response["messages"], list)
                and response["messages"]
            ):
                last_message = response["messages"][-1]

                if hasattr(last_message, "content"):
                    return last_message.content
                elif isinstance(last_message, dict) and "content" in last_message:
                    return last_message["content"]

            # Try other common keys
            for key in ["output", "result", "response"]:
                if key in response and isinstance(response[key], str):
                    return response[key]

            # Fallback: string representation
            return str(response)

        return str(response)

    def get_agent_count(self) -> int:
        """Returns the number of active agents.
        :return: Number of active agent sessions.
        """
        return len(self.agents)

    async def refresh_tools(self):
        """Refresh HTTP MCP tools."""
        try:
            # Refresh HTTP MCP tools
            self.mcp_tools = await self.tool_adapter.refresh_tools()
            print(f"Refreshed {len(self.mcp_tools)} HTTP MCP tools")

            # Recreate all agents with new tools
            old_agents = self.agents.copy()
            self.agents.clear()

            for session_id in old_agents.keys():
                await self._create_agent(session_id)

        except Exception as e:
            print(f"Failed to refresh tools: {e}")

    async def get_available_tools(self) -> list:
        """Get list of all available tools."""
        await self._ensure_tools_loaded()
        all_tools = self._get_all_tools()
        return [
            {"name": tool.name, "description": tool.description} for tool in all_tools
        ]


agent_manager = AgentManager()
