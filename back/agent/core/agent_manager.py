"""
Agent Manager module for managing AI agent lifecycle and interactions.

This module provides the AgentManager class which handles the creation,
management, and message processing for AI agents using LangChain and LangGraph.
"""

import asyncio
from typing import Dict

from dotenv import load_dotenv
from langchain.chat_models import init_chat_model
from langchain.tools import Tool
from langgraph.graph.state import CompiledStateGraph
from langgraph.prebuilt import create_react_agent

from services import get_dynamic_tool_loader

# Load environment variables
load_dotenv()


class AgentManager:
    """
    Manages the lifecycle and interactions of conversation and tool agents.
    """

    def __init__(self):
        """
        Initializes the AgentManager with dynamic tool loading.
        """
        self.static_tools = []
        self.dynamic_tools = []
        self.model = None
        self.agents: Dict[str, CompiledStateGraph] = {}
        self.tool_loader = get_dynamic_tool_loader()

        # Try to initialize the model, but continue without it if credentials are missing
        try:
            self.model = init_chat_model("google_genai:gemini-2.5-flash")
        except Exception as e:
            print(f"Warning: Could not initialize Google Gemini model: {e}")
            print("Agent will continue without LLM capabilities")

        # Load tools asynchronously
        asyncio.create_task(self._load_dynamic_tools())

    async def _load_dynamic_tools(self):
        """Load dynamic tools from service registry."""
        try:
            self.dynamic_tools = await self.tool_loader.load_tools()
            print(f"Loaded {len(self.dynamic_tools)} dynamic tools")
        except Exception as e:
            print(f"Failed to load dynamic tools: {e}")
            self.dynamic_tools = []

    def _get_all_tools(self) -> list:
        """Get all available tools (static + dynamic)."""
        return self.static_tools + self.dynamic_tools

    def _create_agent(self, session_id: str) -> CompiledStateGraph:
        """Creates a new agent for the given session ID.
        :param session_id: Unique identifier for the session.
        :return: An instance of CompiledStateGraph.
        """
        if session_id in self.agents:
            raise ValueError(f"Agent with session_id {session_id} already exists.")

        if self.model is None:
            raise ValueError("Cannot create agent: Language model is not available")

        all_tools = self._get_all_tools()
        agent = create_react_agent(
            tools=all_tools,
            model=self.model,
        )
        self.agents[session_id] = agent
        return self.agents[session_id]

    def _get_or_create_agent(self, session_id: str) -> CompiledStateGraph:
        """Retrieves an existing agent or creates a new one if it doesn't exist.
        :param session_id: Unique identifier for the session.
        """
        if session_id not in self.agents:
            return self._create_agent(session_id)
        return self.agents[session_id]

    def process_message(self, session_id: str, user_input: str) -> str:
        """Processes a user input message through the agent for the given session ID.
        :param session_id: Unique identifier for the session.
        :param user_input: The input message from the user.
        :return: The response generated by the agent.
        """
        if self.model is None:
            return "Error: Language model is not available. Please configure proper credentials."

        agent = self._get_or_create_agent(session_id)
        response = agent.invoke({"messages": [{"role": "user", "content": user_input}]})

        # Debug: Print the full response structure
        print(f"DEBUG: Full response structure: {response}")
        print(f"DEBUG: Response type: {type(response)}")

        # Extract the final message content from LangGraph response
        if isinstance(response, dict):
            # LangGraph typically returns {"messages": [...]}
            if (
                "messages" in response
                and isinstance(response["messages"], list)
                and response["messages"]
            ):
                print(f"DEBUG: Found {len(response['messages'])} messages")
                last_message = response["messages"][-1]
                print(f"DEBUG: Last message: {last_message}")
                print(f"DEBUG: Last message type: {type(last_message)}")

                if hasattr(last_message, "content"):
                    print(f"DEBUG: Using last_message.content: {last_message.content}")
                    return last_message.content
                elif isinstance(last_message, dict) and "content" in last_message:
                    print(
                        f"DEBUG: Using last_message['content']: {last_message['content']}"
                    )
                    return last_message["content"]

            # Try other common keys
            for key in ["output", "result", "response"]:
                if key in response and isinstance(response[key], str):
                    print(f"DEBUG: Using response['{key}']: {response[key]}")
                    return response[key]

            # Fallback: string representation
            print(f"DEBUG: Using fallback str(response)")
            return str(response)

        print(f"DEBUG: Response is not dict, using str(response)")
        return str(response)

    def get_agent_count(self) -> int:
        """Returns the number of active agents.
        :return: Number of active agent sessions.
        """
        return len(self.agents)

    async def refresh_tools(self):
        """Refresh the dynamic tools from service registry."""
        try:
            self.dynamic_tools = await self.tool_loader.refresh_tools()
            print(f"Refreshed {len(self.dynamic_tools)} dynamic tools")

            # Recreate all agents with new tools
            old_agents = self.agents.copy()
            self.agents.clear()

            for session_id in old_agents.keys():
                self._create_agent(session_id)

        except Exception as e:
            print(f"Failed to refresh tools: {e}")

    def get_available_tools(self) -> list:
        """Get list of all available tools."""
        all_tools = self._get_all_tools()
        return [
            {"name": tool.name, "description": tool.description} for tool in all_tools
        ]


agent_manager = AgentManager()
